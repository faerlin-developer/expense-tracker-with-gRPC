/**
 * Transforms the structured logs generated by internal/logger to a human friendly format.
 */

package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
)

func main() {

	scanner := bufio.NewScanner(os.Stdin)

	for scanner.Scan() {
		text := scanner.Text()
		readable := toReadable(text)
		fmt.Println(readable)
	}

	if err := scanner.Err(); err != nil {
		log.Println(err)
	}
}

// toReadable returns structured text as human-readable string.
// The structured text must contain the following fields:
//   - "ts": timestamp
//   - "level": log level (e.g. info, warn, debug, error)
//   - "msg": message log
func toReadable(text string) string {

	var buffer strings.Builder

	// Transform structured text to key-value pairs map
	fields, err := toMap(text)
	if err != nil {
		return text
	}

	// Initialize default fields
	timestamp := fields["ts"]
	level := strings.ToUpper(fields["level"])
	message := fields["msg"]
	traceID := ""
	caller := ""

	if value, ok := fields["traceID"]; ok {
		traceID = value
	}

	if value, ok := fields["caller"]; ok {
		caller = value
	}

	// Write default fields
	buffer.WriteString(fmt.Sprintf("%s [%s]", timestamp, level))
	if traceID != "" {
		buffer.WriteString(fmt.Sprintf(" %s", traceID))
	}
	buffer.WriteString(fmt.Sprintf(" %s ", message))

	// Write optional key-value pairs
	skip := map[string]struct{}{"ts": {}, "level": {}, "traceID": {}, "caller": {}, "msg": {}}
	for k, v := range fields {
		if _, ok := skip[k]; ok {
			continue
		}
		buffer.WriteString(fmt.Sprintf("%s=%v ", k, v))
	}

	// Write caller information at the end of line (if present)
	if caller != "" {
		buffer.WriteString(caller)
	}

	return buffer.String()
}

// toMap returns structured text as a map of key-value pairs.
func toMap(text string) (map[string]string, error) {

	m := make(map[string]any)
	err := json.Unmarshal([]byte(text), &m)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal JSON: %v", err)
	}

	out := make(map[string]string)
	for k, v := range m {
		out[k] = fmt.Sprintf("%v", v)
	}

	return out, nil
}
